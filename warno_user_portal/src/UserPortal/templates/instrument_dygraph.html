<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="{{ url_for('static', filename='dygraph-combined-dev.js')}}"></script>
		<script type="text/javascript" src="{{ url_for('static', filename='jquery-2.1.4.js')}}"></script>
	</head>
	<body>
<!-- 		<br>
		<br>
		<div id="graphdiv0" style="width: 400px; height: 200px;"></div>
		<br>
		<br>
		<div id="graphdiv1" style="width: 400px; height: 200px;"></div>
		<br>
		<hr> -->
		<div>
		    <div style=" vertical-align: top;">
			Add a Graph By Attribute
			<br>
			<select id="keySelect" name="Data">
		        {% for column in columns %}
		          <option value="{{column}}">{{column}}</option>
		       {% endfor %}
	             </select>
		      <button type="button" onclick="add_graph()">Add</button>
		   </div>
		   <div style=" vertical-align: top;">
                  <p><label for="time">Start Date/Time in UTC:</label>
                     <input type="datetime" id="datetime-input-start" name="start" value="01/01/1970 12:27:31">
                  </p>
                  <p><label for="time">End Date/Time in UTC:</label>
                     <input type="datetime" id="datetime-input-end" name="end" value="01/01/2170 12:27:31">
                     <br>
                      (MM/DD/YYYY HH:MM:SS)
                      {% if error %}
                       <div id="new-log-error" style="color: red">{{error}}</div>
                      {% endif %}
                  </p>
		    </div>
		</div>
		<div id="master-graphdiv"></div>

		<script>
   			g = [];
   			id = 0;


            function GraphManager() {
                this.graph_index = 0;
                this.graphs = [];
                this.timer = setInterval(this.tick.bind(this), 2000)
            }

            GraphManager.prototype.tick = function(){
                for (i = 0; i < this.graphs.length; i++){
                    this.graphs[i].tick()
                }
            }

            GraphManager.prototype.add_graph = function(key, beginning_time, end_time) {
                this.graphs.push(new Graph(this.graph_index, key, beginning_time, end_time));
                this.graph_index += 1;
            }

            GraphManager.prototype.get_count = function() {
                return this.graph_index;
            }

            function Graph(id, key, beginning_time, end_time) {
                this.id = id;
                this.key = key;
                this.beginning_time = beginning_time;
                this.end_time = end_time;
                this.graph_data = []

                this.div_id = "graphdiv" + id;
                this.div = document.createElement('div');
                this.div.innerHTML = '<div id = "' + this.div_id + '-parent"><div id="' + this.div_id + '" style="width: 400px; height: 250px; display: inline-block;"></div><br><button type="button" onclick="remove_graph(this)">Remove Graph</button></div>'
                master_div = document.getElementById('master-graphdiv');
                master_div.insertBefore(this.div, master_div.firstChild);
                this.inner_div = document.getElementById(this.div_id);

                this.dygraph = ""

                this.request_values(key, beginning_time, end_time);
            }

            Graph.prototype.update_with_values = function(values) {
                if (this.graph_data.length <= 0) {
                    if (values.length > 0){
                        this.graph_data = this.graph_data.concat(values)
                        this.dygraph = new Dygraph(
                        this.inner_div,
                        this.graph_data,
                        {
                            rollPeriod: 3,
                            showRoller: true,
                            showRangeSelector: true,
                            rangeSelectorHeight: 20,
                            rangeSelectorPlotStrokeColor: 'darkred',
                            rangeSelectorPlotFillColor: 'lightgreen',

                            title: this.key,
                            labels: ["Time", ""],
                            axes: {
                                ticker: function (a, b, pixels, opts, dygraph, vals) {
                                            return Dygraph.getDateAxis(a, b, Dygraph.ANNUAL, opts, dygraph);
                                }
                            }
                        });
                    }
                    else {
                        this.inner_div.innerHTML = "<p>No Data Available<br>Verify that the start and end times are valid and formatted correctly.</p>";
                    }
                }
                else
                {
                    if (values.length > 0) {
                        this.graph_data = this.graph_data.concat(values);
                        this.dygraph.updateOptions({ 'file': data });
                    }
                }
            }

            Graph.prototype.tick = function(){
                //Only update if the last update finished before the specified end time
                if (this.beginning_time <= this.end_time) {
                    this.request_values(this.key, this.beginning_time, this.end_time);
                }
            }

            Graph.prototype.request_values = function(key, beginning_time, end_time) {
                graph_data = "";
                this_graph = this
                xmlhttp = new XMLHttpRequest();

                xmlhttp.onreadystatechange = function() {
                    //After the asyncronous request successfully returns
                    if (xmlhttp.readyState == 4 && xmlhttp.status == 200)
                    {
                        //Pull out the response text from the request
                        rec_message = JSON.parse(xmlhttp.responseText);
                        values = []

                        if (rec_message["x"].length > 0)
                        {
                            for (i = 0; i < rec_message["x"].length; i ++)
                            {
                                values.push([new Date(rec_message["x"][i]), rec_message["y"][i]]);
                            }

                        }

                        this_graph.update_with_values(values);
                    }
                }
			    //Send JSON POST XMLHTTPRequest to generator controller.
                //Include keys for the generated graph, and convert start and end datetimes to a valid argument format
                //Assume input is in UTC

                start_utc = beginning_time.toLocaleString();
                end_utc = end_time.toLocaleString();

                url = "{{url_for('instruments.generate_instrument_graph')}}" + "?key=" + key + "&instrument_id=" + {{instrument_id}} + "&start=" + start_utc + "&end=" + end_utc;
                xmlhttp.open("POST", url, true);

                //Send out the request
				xmlhttp.send();

				//Set the beginning time for this graph to now.  This meand updating the graph will only add new values.
                this.beginning_time = new Date()
            }

            gm = new GraphManager();

			function add_graph()
				{

					key = document.getElementById('keySelect').value;

					start_str = document.getElementById("datetime-input-start").value;
					start = new Date(start_str);
					end_str = document.getElementById("datetime-input-end").value;
					end = new Date(end_str)

                    gm.add_graph(key, start, end);

				};
			function remove_graph(e)
				{
					id = e.closest("div").id;
					elem = document.getElementById(id);
					elem.parentNode.removeChild(elem);
				}
		</script>
	</body>



</html>
